# Omnivore - Read-it-later Application Rules

## Project Overview

Omnivore is a complete, open-source read-it-later solution with web, mobile, and browser extension clients. The architecture uses:

- GraphQL API backend (Node.js/TypeScript)
- Next.js frontend with TypeScript
- PostgreSQL database with vector extensions
- Redis for caching and queues
- Microservices for content processing
- Mobile apps (iOS/Android)
- Browser extensions

## Architecture Rules

### Monorepo Structure

- Use Lerna for package management across the monorepo
- Each service should be in its own package under `packages/` or `pkg/`
- Shared utilities should be in `packages/utils`
- Database schemas and migrations in `packages/db`
- Web frontend in `packages/web`
- API server in `packages/api`

### TypeScript Standards

- Use strict TypeScript configuration
- Prefer interfaces over types for object shapes
- Use enums for constants with multiple values
- Always define return types for functions
- Use optional chaining and nullish coalescing operators
- Avoid `any` type - use `unknown` if needed
- Use proper generic constraints

### GraphQL API Patterns

- Follow GraphQL best practices with proper schema design
- Use GraphQL Code Generator for type generation
- Implement proper error handling with GraphQL error types
- Use DataLoader pattern for N+1 query prevention
- Implement proper authentication and authorization
- Use subscriptions for real-time features
- Follow relay-style pagination for lists

### Database Patterns

- Use migrations for all schema changes
- Place migrations in `packages/db/migrations/`
- Use descriptive migration names with timestamps
- Always include both up and down migrations
- Use proper indexing for performance
- Implement soft deletes where appropriate
- Use database transactions for complex operations

### Frontend (Next.js) Patterns

- Use App Router for new features
- Implement proper SSR/SSG where beneficial
- Use SWR for data fetching and caching
- Follow component composition patterns
- Use Stitches for styling (already in use)
- Implement proper error boundaries
- Use TypeScript with proper prop types
- Follow accessibility best practices

### Docker and Containerization

- Each service should have its own Dockerfile
- Use multi-stage builds for production images
- Implement proper health checks
- Use docker-compose for local development
- Follow security best practices in containers
- Use .dockerignore files appropriately

### Testing Standards

- Write unit tests for all business logic
- Use integration tests for API endpoints
- Implement E2E tests for critical user flows
- Use proper mocking for external dependencies
- Maintain test coverage above 80%
- Use descriptive test names and organize in suites

### Mobile Development

- iOS: Use Swift with SwiftUI
- Android: Use Kotlin with Jetpack Compose
- Share GraphQL schemas between platforms
- Implement proper offline capabilities
- Use platform-specific UI patterns
- Handle deep linking appropriately

### Browser Extension Development

- Support Chrome, Firefox, Safari, and Edge
- Use Manifest V3 where applicable
- Implement proper content security policies
- Handle permissions appropriately
- Use background scripts efficiently
- Implement proper error handling

### Code Quality

- Use ESLint with TypeScript support
- Follow Prettier formatting
- Use consistent naming conventions
- Implement proper logging
- Use environment variables for configuration
- Follow SOLID principles
- Implement proper error handling

### Performance Considerations

- Implement proper caching strategies
- Use database indexes appropriately
- Optimize bundle sizes for web and mobile
- Implement lazy loading where beneficial
- Use CDN for static assets
- Monitor performance metrics

### Security Guidelines

- Implement proper authentication (JWT)
- Use HTTPS everywhere
- Validate all inputs
- Implement proper CORS policies
- Use environment variables for secrets
- Regular security audits
- Implement rate limiting

### API Design

- Follow RESTful principles for REST endpoints
- Use proper HTTP status codes
- Implement proper versioning
- Use consistent error response formats
- Implement proper pagination
- Use proper HTTP methods
- Document all APIs

### Documentation Standards

- Update README.md when adding new features
- Document all environment variables
- Maintain API documentation
- Include setup instructions for new developers
- Document deployment procedures
- Use inline comments for complex logic

### Development Workflow

- Use feature branches for development
- Implement proper CI/CD pipelines
- Use semantic versioning
- Write meaningful commit messages
- Use pull request templates
- Implement proper code review processes

### Environment Management

- Use different configurations for dev/staging/prod
- Implement proper secrets management
- Use environment-specific docker-compose files
- Implement proper logging levels
- Use monitoring and alerting

### Content Processing

- Implement proper content extraction
- Use readability algorithms for article parsing
- Handle different content types (PDF, articles, etc.)
- Implement proper error handling for content fetching
- Use queues for background processing
- Implement retry mechanisms

### User Experience

- Implement proper loading states
- Use optimistic updates where appropriate
- Handle offline scenarios gracefully
- Implement proper error messages
- Use consistent UI patterns
- Implement proper keyboard navigation

## File-specific Rules

### GraphQL Schema Files

- Use descriptive field names
- Implement proper type relationships
- Use unions for polymorphic types
- Document schema with descriptions
- Follow GraphQL naming conventions

### React Components

- Use functional components with hooks
- Implement proper prop validation
- Use consistent naming (PascalCase)
- Keep components focused and small
- Use proper state management
- Implement proper cleanup in useEffect

### API Handlers

- Implement proper error handling
- Use proper HTTP status codes
- Validate input parameters
- Implement proper logging
- Use proper middleware patterns
- Handle edge cases gracefully

### Database Models

- Use proper relationships
- Implement proper validations
- Use descriptive field names
- Implement proper indexes
- Use proper data types
- Handle cascading properly

Remember: This is a complex application with multiple platforms. Always consider the impact of changes across web, mobile, and browser extension clients. Prioritize user experience and data consistency across all platforms.
